;---------------------------------------------------
; Programa: MULTIPLICAÇÃO 8 BITS
; Autor: GABRIEL AUREO
; Data: 04/09/2018
;---------------------------------------------------

;VARIAVEIS DA ROTNA PRINCIPAL
ORG 0
  TEST: DW 55
  N: DB 0
  PN : DW N
  M: DB 0
  PM: DW M
  RES: DW 0
  PRES: DW RES

ORG 100

MAIN:
  LDA PN
  PUSH
  LDA PN +1
  PUSH
  JSR SCAN
  LDA PM
  PUSH
  LDA PM+1
  PUSH
  JSR SCAN


  LDA PN
  PUSH
  LDA PN +1
  PUSH
  LDA PM
  PUSH
  LDA PM +1
  PUSH
  LDA PRES
  PUSH
  LDA PRES +1
  PUSH
  JSR MULT
  HLT
  END MAIN

ORG 300

;VARIAVEIS SCANB

SP0: DW 0
INPUT: DW 0

ORG 500
;SUBROTINA QUE SCANEIA ENTRADA E GUARDA EM UM PONTEIRO PASSADO PELA PILHA
SCAN:
  STS SP0
  POP
  POP
  POP
  STA INPUT +1
  POP
  STA INPUT

INPUTLOOP:
  IN 1
  AND #1
  JZ INPUTLOOP
  IN 0
  STA @INPUT

  LDS SP0
  RET

ORG 800
  X: DW 0
  Y: DW 0
  ;X E Y SÃO INICIALIZADAS COM 2 BYTES CADA PARA NÃO SER PRECISO DECLARAR PONTEIROS INDIVIDUAIS
  Z: DW 0 ;VARIÁVEL PARA ACUMULAR AS SOMAS DE ENTRE X E Y
  PTR: DW 0 ;PONTEIRO PARA O RESULTADO
  HIOF: DB 0 ;VARIÁVEL USADA PARA GUARDAR FLAG DE OVERFLOW AO DUPLICAR X
  OF: DB 0 ;FLAG DE OVERFLOW DA MULTIPLICAÇÃO
  SP1: DW 0

ORG 1000
;ROTINA DE MULTIPLICAÇÃO BASEADA NO ALGORITMO DE MULTIPLICAÇÃO RUSSA
;PSEUDOCÓDIGO:
;1)RESULTADO = 0
;2)ENQUANTO Y > 0
  ;A) SE Y FOR ÍMPAR, SOMAR X AO RESULTADO
  ;B) DUPLICAR X E DIVIDIR Y POR 2
MULT:
  STS SP1
  POP
  POP
  POP
  STA PTR + 1
  POP
  STA PTR
  POP
  ;CARREGA Y COM O ENDEREÇO DE M
  STA Y+1
  POP
  STA Y
  ;CARREGA X COM O ENDEREÇO DE N
  POP
  STA X+1
  POP
  STA X

  ;CARREGA X E Y COM OS VALORES DE N E M
  LDA @X
  STA X
  LDA @Y
  STA Y

  ;VERIFICA SE É UMA MULTIPLICAÇÃO DE NEGATIVOS E CONVERTE PARA POSITIVOS
  LDA X
  AND Y
  JN NEGATE
  JMP EXTEND
NEGATE:
  LDA #0
  SUB X
  STA X
  LDA #0
  SUB Y
  STA Y
  LDA #1
  ;SETA A FLAG DE OVERFLOW
  STA OF
  JMP INVERT

  ;EXTENDE X E Y NEGATIVOS PARA 2 BYTES
EXTEND:
  LDA @X
  STA X
  JN EXTENDX
  JMP EXTENDY
EXTENDX:
  LDA #1
  STA OF
  LDA #0FFH
  STA X+1

  LDA @Y
  STA Y
  JN EXTENDY
  JMP MULTLOOP
EXTENDY:
  LDA #1
  STA OF
  LDA #0FFH
  STA Y+1

INVERT:
  ;INVERTE X E Y CASO X SEJA MAIOR QUE Y (REDUZ A QUANTIDADE DE ITERAÇÕES DA MULTIPLICAÇÃO)
  LDA X
  SUB Y
  JN SWAP
  JMP MULTLOOP
  SWAP:
  LDA @X
  STA Z
  LDA @Y
  STA X
  LDA Z
  STA Y

MULTLOOP:
;VERIFICA SE Y FOI DIVIDIDO AO PONTO DE CHEGAR A 0 OU -1
  LDA Y
  JZ RETURN
  NOT
  JZ RETURN
  LDA Y
  AND #1
  JZ SHIFT

SOMA:
  LDA Z
  ADD X
  STA Z
  LDA Z+1
  ADC X+1
  STA Z+1
  JC RETURN
;CASO OCORRA OVERFLOW AO INCREMENTAR O RESULTADO, OBRIGATORIAMENTE O VALOR DA MULTIPLICAÇÃO FOI ALCANÇANDO, PORTANTO A ROTINA PODE TERMINAR

SHIFT:
;DOBRA O PRIMEIRO VALOR
  LDA X
  SHL
  STA X
  LDA #0
  JNC HISHIFT
  LDA #1

HISHIFT:
  STA HIOF
  LDA X+1
  SHL
  ADD HIOF
  STA X+1
;DIVIDE O SEGUNDO VALOR
  LDA Y
  SRA
  STA Y
  JMP MULTLOOP

RETURN:
  LDA OF
  LDS Z
  STS @PTR
  LDS SP1
  RET

